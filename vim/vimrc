augroup vimrc
  autocmd!
augroup END

let mapleader = "\<space>"
let maplocalleader = '\<space>'


" ============================================================================
" VIM-PLUG
" ============================================================================
" Specify a directory for plugins (for Neovim: ~/.local/share/nvim/plugged)
call plug#begin('~/.vim/bundle')

" ----------------------------------------------------------------------------
" Neovim 0.6
" ----------------------------------------------------------------------------
" Plug 'dstein64/vim-startuptime'
Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}  " We recommend updating the parsers on update
Plug 'nvim-treesitter/nvim-treesitter-textobjects'
Plug 'nvim-treesitter/nvim-treesitter-context'
Plug 'numToStr/Comment.nvim'
" Plug 'JoosepAlviste/nvim-ts-context-commentstring'
Plug 'nvim-lualine/lualine.nvim'
" Plug 'akinsho/bufferline.nvim'
Plug 'simrat39/symbols-outline.nvim'
" Plug 'rmagatti/goto-preview'
Plug 'nvim-lua/plenary.nvim'
Plug 'TimUntersberger/neogit'
Plug 'akinsho/toggleterm.nvim'
Plug 'nvim-telescope/telescope.nvim'
Plug 'nvim-telescope/telescope-fzf-native.nvim', { 'do': 'make' }

Plug 'ray-x/lsp_signature.nvim'
" Plug 'williamboman/nvim-lsp-installer'
Plug 'williamboman/mason.nvim'
Plug 'williamboman/mason-lspconfig.nvim'
Plug 'neovim/nvim-lspconfig'
Plug 'jose-elias-alvarez/null-ls.nvim'
Plug 'hrsh7th/cmp-nvim-lsp'
Plug 'hrsh7th/cmp-buffer'
Plug 'hrsh7th/cmp-path'
Plug 'hrsh7th/cmp-cmdline'
Plug 'hrsh7th/nvim-cmp'
" Plug 'hrsh7th/cmp-vsnip'
" Plug 'hrsh7th/vim-vsnip'
Plug 'SirVer/ultisnips'
Plug 'quangnguyen30192/cmp-nvim-ultisnips'
" Plug 'github/copilot.vim'
" Plug 'zbirenbaum/copilot.lua'
" Plug 'zbirenbaum/copilot-cmp'
Plug 'antoinemadec/FixCursorHold.nvim'
  " https://github.com/neovim/neovim/issues/12587
  " in millisecond, used for both CursorHold and CursorHoldI,
  " use updatetime instead if not defined
  let g:cursorhold_updatetime = 100
Plug 'kevinhwang91/promise-async'
Plug 'kevinhwang91/nvim-ufo'
Plug 'anuvyklack/hydra.nvim'
Plug 'b0o/incline.nvim'
Plug 'glepnir/lspsaga.nvim', { 'branch': 'main' }
Plug 'SmiteshP/nvim-navic'
Plug 'chipsenkbeil/distant.nvim'
Plug 'sindrets/diffview.nvim'

Plug 'anuvyklack/middleclass'
Plug 'anuvyklack/animation.nvim'
Plug 'anuvyklack/windows.nvim'


" ----------------------------------------------------------------------------
" appearance
" ----------------------------------------------------------------------------
Plug 'arcticicestudio/nord-vim'
" Plug 'shaunsingh/nord.nvim'
Plug 'ishan9299/nvim-solarized-lua'
Plug 'folke/tokyonight.nvim'
Plug 'rebelot/kanagawa.nvim'
Plug 'kyazdani42/nvim-web-devicons'
Plug 'NLKNguyen/papercolor-theme'
Plug 'morhetz/gruvbox'
Plug 'EdenEast/nightfox.nvim'
Plug 'lukas-reineke/indent-blankline.nvim'
  let g:indent_blankline_filetype = ['c', 'cpp']
  let g:indent_blankline_use_treesitter = v:true
  " let g:indent_blankline_show_trailing_blankline_indent = v:false
  let g:indent_blankline_show_first_indent_level = v:false

" ----------------------------------------------------------------------------
" appearance
" ----------------------------------------------------------------------------
Plug 'machakann/vim-highlightedyank'
Plug 'google/vim-searchindex'
Plug 'junegunn/goyo.vim'
Plug 'junegunn/limelight.vim'
Plug 'kshenoy/vim-signature'
" Plug 'airblade/vim-gitgutter'
Plug 'mhinz/vim-signify'
    let g:signify_sign_change = '~'
Plug 'tpope/vim-fugitive'
Plug 'kevinhwang91/nvim-bqf'
Plug 'folke/which-key.nvim'
" Plug 'Yggdroot/indentLine', { 'for': ['cpp', 'c']}
" Plug 'bling/vim-airline'
" Plug 'ryanoasis/vim-devicons'
" Plug 'sheerun/vim-polyglot'

" Plug 'liuchengxu/vim-which-key', { 'on': ['WhichKey', 'WhichKey!'] }
"   nnoremap <silent> <leader> :WhichKey '<Space>'<CR>

Plug 'mhinz/vim-startify'
  let g:startify_files_number=5
  let g:startify_files_number=5
  let g:startify_list_order = [
        \ ["   MRU " . getcwd()],
        \ 'dir',
        \ ['   MRU'],
        \ 'files',
        \ ['   sessions:'],
        \ 'sessions',
        \ ]

  " let g:startify_session_autoload = 1
  " let g:startify_session_before_save = [
  "       \ 'echo "Saving session.."',
  "       \ ]
  " let g:startify_session_persistence = 0
  " let g:startify_session_savevars = [
  "       \ 'g:startify_session_savevars',
  "       \ 'g:startify_session_savecmds',
  "       \ 'g:random_plugin_use_feature'
  "       \ ]


" ----------------------------------------------------------------------------
" complete
" ----------------------------------------------------------------------------
Plug 'wellle/tmux-complete.vim'
Plug 'honza/vim-snippets'
" Plug 'neoclide/coc.nvim', {'branch': 'release'}

" ----------------------------------------------------------------------------
" surround
" ----------------------------------------------------------------------------
Plug 'Raimondi/delimitMate'
  augroup delimitMate
    autocmd!
    autocmd FileType plaintex,tex let b:delimitMate_quotes = "\" ' $"
  augroup END
  let delimitMate_expand_space = 1
  let delimitMate_expand_cr = 1
  let delimitMate_jump_expansion = 1

Plug 'tpope/vim-surround'
  augroup vim-surround
    autocmd!
    autocmd fileType plaintex,tex let b:surround_{char2nr('b')} = "\\textbf{\r}"
    autocmd fileType plaintex,tex let b:surround_{char2nr('i')} = "\\textit{\r}"
    autocmd fileType plaintex,tex let b:surround_{char2nr('$')} = "$\r$"
    autocmd fileType plaintex,tex let g:surround_{char2nr('c')} = "\\\1command\1{\r}"
  augroup END

" ----------------------------------------------------------------------------
" navigation
" ----------------------------------------------------------------------------
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' } | Plug 'junegunn/fzf.vim'
Plug 'andymass/vim-matchup'
Plug 'christoomey/vim-tmux-navigator'
  let g:tmux_navigator_no_mappings = 1
  nnoremap <silent> <c-h> :TmuxNavigateLeft<cr>
  nnoremap <silent> <c-j> :TmuxNavigateDown<cr>
  nnoremap <silent> <c-k> :TmuxNavigateUp<cr>
  nnoremap <silent> <c-l> :TmuxNavigateRight<cr>
Plug 'psliwka/vim-smoothie'
" Plug 'majutsushi/tagbar' "need exuberant ctag installed

Plug 'kyazdani42/nvim-tree.lua'
  nnoremap ge :NvimTreeToggle<CR>

" Plug 'Lokaltog/vim-easymotion'
"   map <Leader> <Plug>(easymotion-prefix)
"   map <silent> <Leader>ml <Plug>(easymotion-lineforward)
"   map <silent> <Leader>mj <Plug>(easymotion-j)
"   map <silent> <Leader>mk <Plug>(easymotion-k)
"   map <silent> <Leader>mh <Plug>(easymotion-linebackward)
"   let g:EasyMotion_startofline = 0 " Keep cursor colum when JK motion

" Plug 'phaazon/hop.nvim'
Plug 'ggandor/leap.nvim'

" Plug 'mileszs/ack.vim' "need rg installed
"   if executable('rg')
"     " let g:ackprg = 'ag --nogroup --nocolor --column'
"     let g:ackprg = 'rg --vimgrep'
"   endif
"   let g:ack_autoclose = 0
"   nnoremap <Leader>rw :AckWindow <cword><cr>
"   nnoremap <Leader>rW :Ack <cword><cr>

Plug 'mbbill/undotree', { 'do': 'mkdir ~/.undodir'}
  nnoremap U :UndotreeToggle<cr>
  let g:undotree_WindowLayout = 2
  if has("persistent_undo")
    set undodir=~/.undodir/
    set undofile
  endif

" Plug 'dhruvasagar/vim-zoom'
"   nmap <silent> <Leader>z <Plug>(zoom-toggle)

" Plug 'troydm/zoomwintab.vim'
"   nmap  <Leader>z <cmd>ZoomWinTabToggle<CR>
"   let g:zoomwintab_hidetabbar = 0

" Plug 'justinmk/vim-gtfo'
  " let g:gtfo#terminals = { 'unix': 'alacritty --working-directory' }

" ----------------------------------------------------------------------------
" writing
" ----------------------------------------------------------------------------
Plug 'rhysd/vim-grammarous'
  let g:grammarous#hooks = {}
  function! g:grammarous#hooks.on_check(errs) abort
    nmap <buffer>gn <Plug>(grammarous-move-to-next-error)
    nmap <buffer>gp <Plug>(grammarous-move-to-previous-error)
    nmap <buffer>gf <Plug>(grammarous-fixit)
  endfunction
  function! g:grammarous#hooks.on_reset(errs) abort
    nunmap <buffer>gn
    nunmap <buffer>gp
    nunmap <buffer>gf
  endfunction

Plug 'reedes/vim-lexical'
  augroup lexical
    autocmd!
    autocmd FileType text call lexical#init()
    autocmd FileType plaintex,tex call lexical#init()
    autocmd FileType markdown call lexical#init()
  augroup END
  let g:lexical#spell_key = 'z='

Plug 'voldikss/vim-translator'
  nmap <silent> <Leader>tw <Plug>TranslateW
  vmap <silent> <Leader>tw <Plug>TranslateWV

" ----------------------------------------------------------------------------
" latex
" ----------------------------------------------------------------------------
Plug 'KeitaNakamura/tex-conceal.vim', {'for': 'tex'}
" Plug 'lervag/vimtex'
" Plug 'Konfekt/FastFold'
" Plug 'gi1242/vim-tex-syntax'

" ----------------------------------------------------------------------------
" edit
" ----------------------------------------------------------------------------
Plug 'tpope/vim-obsession'
" Plug 'rmagatti/auto-session'
Plug 'mfussenegger/nvim-dap'
Plug 'rcarriga/nvim-dap-ui'
" Plug 'Pocco81/dap-buddy.nvim', { 'commit': '24923c3' }
" Plug 'terryma/vim-multiple-cursors'
Plug 'mg979/vim-visual-multi'
Plug 'tpope/vim-repeat'
Plug 'dhruvasagar/vim-table-mode'
Plug 'AndrewRadev/linediff.vim'
Plug 'kana/vim-textobj-user'
" Plug 'tomtom/tcomment_vim'
" Plug 'vim-scripts/ReplaceWithRegister'
" Plug 'sakhnik/nvim-gdb', { 'do': ':UpdateRemotePlugins' }
" Plug 'sakhnik/nvim-gdb', { 'do': ':!./install.sh \| UpdateRemotePlugins' }
" Plug 'sakhnik/nvim-gdb', { 'branch': 'legacy' }
" Plug 'suan/vim-instant-markdown', { 'do': function('BuildMD') }
"

" Plug 'brooth/far.vim'
"   let g:far#source='rg'

Plug 'tpope/vim-markdown'
Plug 'iamcco/markdown-preview.nvim', { 'do': 'cd app & yarn install'  }
  nmap <leader>mp <Plug>MarkdownPreviewToggle

Plug 'sk1418/HowMuch'
  "The scale of the result:
  let g:HowMuch_scale = 2
  "the engine order for auto-calculation
  let g:HowMuch_auto_engines = ['bc', 'vim', 'py']


" Plug 'w0rp/ale', { 'for': ['sh', 'tex', 'latex', 'text']} "apt-get install shellcheck, vale or writegood or proselint
"   " For all languages unspecified in the dictionary, all possible linters will be run for those languages, just as when the dictionary is not defined.
"   let g:ale_linters = {
"   \   'tex' : ['chktex', 'vale'],
"   \   'latex' : ['chktex', 'vale'],
"   \   'text': ['vale'],
"   \}

Plug 'junegunn/vim-easy-align',  { 'on': ['<Plug>(EasyAlign)', 'EasyAlign'] }
  " Start interactive EasyAlign in visual mode (e.g. vipga)
  xmap ga <Plug>(EasyAlign)
  " Start interactive EasyAlign for a motion/text object (e.g. gaip)
  nmap ga <Plug>(EasyAlign)
  let g:easy_align_delimiters = {
        \  't': { 'pattern': '\t',  'left_margin': 1, 'right_margin': 1, 'stick_to_left': 0 }
        \}

Plug 'chrisbra/vim-diff-enhanced'
  if &diff
    let &diffexpr='EnhancedDiff#Diff("git diff", "--diff-algorithm=patience")'
  endif

" Initialize plugin system
call plug#end()


" ============================================================================
" Lua config
" ============================================================================
lua << END

-- require("copilot").setup { plugin_manager_path = os.getenv("HOME") .. "/.vim/bundle", }

------------------------------------------------------------------------------
-- mason
------------------------------------------------------------------------------
require("mason").setup()
require("mason-lspconfig").setup()
require("nvim-navic").setup()

------------------------------------------------------------------------------
-- nvim-cmp
------------------------------------------------------------------------------
  local cmp = require'cmp'
  local cmp_ultisnips_mappings = require("cmp_nvim_ultisnips.mappings")
  cmp.setup({
    snippet = {
      -- REQUIRED - you must specify a snippet engine
      expand = function(args)
        -- vim.fn["vsnip#anonymous"](args.body) -- For `vsnip` users.
        -- require('luasnip').lsp_expand(args.body) -- For `luasnip` users.
        -- require('snippy').expand_snippet(args.body) -- For `snippy` users.
        vim.fn["UltiSnips#Anon"](args.body) -- For `ultisnips` users.
      end,
    },
  mapping = {
    ["<Tab>"] = cmp.mapping(function(fallback)
      if cmp.visible() then
        cmp.select_next_item()
      else
        fallback() -- The fallback function sends a already mapped key. In this case, it's probably `<Tab>`.
      end
    end, { "i", "s" }),

    ["<S-Tab>"] = cmp.mapping(function()
      if cmp.visible() then
        cmp.select_prev_item()
      end
    end, { "i", "s" }),

    ["<CR>"] = cmp.mapping(function(fallback)
      cmp_ultisnips_mappings.compose { "expand" } (fallback)
    end, { "i", "s" }),


      ['<C-b>'] = cmp.mapping(cmp.mapping.scroll_docs(-4), { 'i', 'c' }),
      ['<C-f>'] = cmp.mapping(cmp.mapping.scroll_docs(4), { 'i', 'c' }),
      ['<C-Space>'] = cmp.mapping(cmp.mapping.complete(), { 'i', 'c' }),
      ['<C-y>'] = cmp.config.disable, -- Specify `cmp.config.disable` if you want to remove the default `<C-y>` mapping.
      ['<C-e>'] = cmp.mapping({
        i = cmp.mapping.abort(),
        c = cmp.mapping.close(),
      }),
      ['<CR>'] = cmp.mapping.confirm({ select = false }), -- Accept currently selected item. Set `select` to `false` to only confirm explicitly selected items.
    },
    sources = cmp.config.sources({
      -- { name = 'copilot' },
      -- { name = 'vsnip' }, -- For vsnip users.
      -- { name = 'luasnip' }, -- For luasnip users.
      { name = 'ultisnips' }, -- For ultisnips users.
      -- { name = 'snippy' }, -- For snippy users.
      { name = 'nvim_lsp' },
    }, {
      { name = 'buffer' },
      { name = 'path' },
      { name = 'cmdline' },
    })
  })

  -- Use buffer source for `/` (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline('/', {
    sources = {
      { name = 'buffer' }
    }
  })

  -- Use cmdline & path source for ':' (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline(':', {
    sources = cmp.config.sources({
      { name = 'path' }
    }, {
      { name = 'cmdline' }
    })
  })

  -- Setup lspconfig.
  local custom_lsp_attach = function(client, bufnr)
    if client.server_capabilities.documentHighlightProvider then
      vim.cmd [[
        augroup lsp_document_highlight
          autocmd! * <buffer>
          autocmd! CursorHold <buffer> lua vim.lsp.buf.document_highlight()
          autocmd! CursorMoved <buffer> lua vim.lsp.buf.clear_references()
        augroup END
      ]]
    end
    require("nvim-navic").attach(client, bufnr)
end

  -- setup lspconfig
  local capabilities = require('cmp_nvim_lsp').update_capabilities(vim.lsp.protocol.make_client_capabilities())
  -- local capabilities = require('cmp_nvim_lsp').update_capabilities(vim.lsp.protocol.make_client_capabilities(), {
  --   snippetSupport = false,
  --   })
  capabilities.offsetEncoding = { "utf-16" } -- TODO https://github.com/jose-elias-alvarez/null-ls.nvim/issues/428

  -- Replace <YOUR_LSP_SERVER> with each lsp server you've enabled.
  require('lspconfig')['clangd'].setup {
    capabilities = capabilities,
    on_attach = custom_lsp_attach
  }

  vim.lsp.handlers["textDocument/hover"] = vim.lsp.with(
  vim.lsp.handlers.hover, {
    -- Use a sharp border with `FloatBorder` highlights
    border = "single"
    }
  )

------------------------------------------------------------------------------
-- null-ls
------------------------------------------------------------------------------
local null_ls = require("null-ls").null_ls
require("null-ls").setup({
    sources = {
      -- require("null-ls").builtins.diagnostics.cppcheck,
      -- require("null-ls").builtins.formatting.clang_format,
    },
})

------------------------------------------------------------------------------
-- lsp_signature.nvim
------------------------------------------------------------------------------
require "lsp_signature".setup{}

------------------------------------------------------------------------------
-- nvim-treesitter
------------------------------------------------------------------------------
require'nvim-treesitter.configs'.setup {
  -- One of "all", "maintained" (parsers with maintainers), or a list of languages
  ensure_installed = {"c", "cpp", "bash", "vim", "lua", "python"},

  -- Install languages synchronously (only applied to `ensure_installed`)
  sync_install = false,

  highlight = {
    -- `false` will disable the whole extension
    enable = true,

    -- Setting this to true will run `:h syntax` and tree-sitter at the same time.
    -- Set this to `true` if you depend on 'syntax' being enabled (like for indentation).
    -- Using this option may slow down your editor, and you may see some duplicate highlights.
    -- Instead of true it can also be a list of languages
    additional_vim_regex_highlighting = false,
  },
  -- indent = {
  --   enable = true
  -- },

  -- context_commentstring = { -- nvim-ts-context-commentstring
  --   enable = true
  -- },

  textobjects = {
    move = {
    enable = true,
    set_jumps = true, -- whether to set jumps in the jumplist
    goto_next_start = {
      ["]m"] = "@function.outer",
      ["]]"] = "@class.outer",
      },
    goto_next_end = {
      ["]M"] = "@function.outer",
      ["]["] = "@class.outer",
      },
    goto_previous_start = {
      ["[m"] = "@function.outer",
      ["[["] = "@class.outer",
      },
    goto_previous_end = {
      ["[M"] = "@function.outer",
      ["[]"] = "@class.outer",
      },
    },
  },

  matchup = {
    enable = true,              -- mandatory, false will disable the whole extension
    disable_virtual_text = true,
  },
}

require'treesitter-context'.setup{
    enable = enabled, -- Enable this plugin (Can be enabled/disabled later via commands)
    throttle = true, -- Throttles plugin updates (may improve performance)
    max_lines = 0, -- How many lines the window should span. Values <= 0 mean no limit.
    patterns = { -- Match patterns for TS nodes. These get wrapped to match at word boundaries.
        -- For all filetypes
        -- Note that setting an entry here replaces all other patterns for this entry.
        -- By setting the 'default' entry below, you can control which nodes you want to
        -- appear in the context window.
        default = {
            'class',
            'function',
            'method',
            -- 'for', -- These won't appear in the context
            -- 'while',
            -- 'if',
            -- 'switch',
            -- 'case',
        },
        -- Example for a specific filetype.
        -- If a pattern is missing, *open a PR* so everyone can benefit.
        --   rust = {
        --       'impl_item',
        --   },
    },
    exact_patterns = {
        -- Example for a specific filetype with Lua patterns
        -- Treat patterns.rust as a Lua pattern (i.e "^impl_item$" will
        -- exactly match "impl_item" only)
        -- rust = true,
    }
}

require('Comment').setup { -- with ts_context_commentstring
-- -- NOTE: The example below is a proper integration and it is RECOMMENDED.
-- ---@param ctx Ctx
-- pre_hook = function(ctx)
--     -- Only calculate commentstring for tsx filetypes
--     if vim.bo.filetype == 'typescriptreact' then
--         local U = require('Comment.utils')
--
--         -- Determine whether to use linewise or blockwise commentstring
--         local type = ctx.ctype == U.ctype.line and '__default' or '__multiline'
--
--         -- Determine the location where to calculate commentstring from
--         local location = nil
--         if ctx.ctype == U.ctype.block then
--             location = require('ts_context_commentstring.utils').get_cursor_location()
--         elseif ctx.cmotion == U.cmotion.v or ctx.cmotion == U.cmotion.V then
--             location = require('ts_context_commentstring.utils').get_visual_start_location()
--         end
--
--         return require('ts_context_commentstring.internal').calculate_commentstring({
--             key = type,
--             location = location,
--         })
--     end
-- end,
}
require'nvim-tree'.setup()

------------------------------------------------------------------------------
-- lualine
------------------------------------------------------------------------------
local navic = require("nvim-navic")
require('lualine').setup {
  sections = {
    lualine_c = {'filename', { navic.get_location, cond = navic.is_available }},
  },
  options = {
    -- ... your lualine config
    globalstatus = true,        -- enable global statusline (have a single statusline
    -- theme = 'nord'
  }
}

------------------------------------------------------------------------------
-- bufferline
------------------------------------------------------------------------------
-- require("bufferline").setup{
--   options = {
--     -- mode = 'tabs'
--     }
-- }

------------------------------------------------------------------------------
-- nvim-web-devicons
------------------------------------------------------------------------------
require'nvim-web-devicons'.setup {
 -- globally enable default icons (default to false)
 -- will get overriden by `get_icons` option
 default = true;
}

------------------------------------------------------------------------------
-- indent_blankline
------------------------------------------------------------------------------
require("indent_blankline").setup {
    -- for example, context is off by default, use this to turn it on
    show_current_context = true,
}

------------------------------------------------------------------------------
-- dap ccppr_vsc
------------------------------------------------------------------------------
local dap = require('dap')
dap.adapters.cppdbg = {
  id = 'cppdbg',
  type = 'executable',
  command = vim.fn.stdpath("data") .. "/mason/bin/OpenDebugAD7",
}
dap.configurations.cpp = {
  {
    name = "z3",
    type = "cppdbg",
    request = "launch",
    program = os.getenv("HOME") .. '/smt/z3_code/build/z3',
  
    cwd = '${workspaceFolder}',
    stopOnEntry = true,
    setupCommands = {
      {
          text = '-enable-pretty-printing',
          description =  'enable pretty printing',
          ignoreFailures = false
      },
      {
          text = 'set args /pub/data/linjk/smt/incremental/QF_BV/20170501-Heizmann-UltimateAutomizer/gcd_1_true-unreach-call_true-no-overflow.i.smt2',
          
          
          description = 'instance',
          ignoreFailures = flase
      },
    },
  },
  {
    name = "bitwuzla",
    type = "cppdbg",
    request = "launch",
    program = os.getenv("HOME") .. '/smt/bitwuzla/build/bin/bitwuzla',
  
    cwd = '${workspaceFolder}',
    stopOnEntry = true,
    setupCommands = {
      {
          text = '-enable-pretty-printing',
          description =  'enable pretty printing',
          ignoreFailures = false
      },
      {
          text = 'set args /home/linjk/smt/2021_QF_BV/2017-BuchwaldFried/counterexample.dump.ia32_Mul_base_disp--Add32.load32.Mul32.Mulh_u32.0005.smt2 -v',
          
          description = 'instance',
          ignoreFailures = flase
      },
    },
  },
  {
    name = "Launch file",
    type = "cppdbg",
    request = "launch",
    program = function()
      return vim.fn.input('Path to executable: ', vim.fn.getcwd() .. '/', 'file')
    end,
    cwd = '${workspaceFolder}',
    stopOnEntry = true,
    setupCommands = {
      {
          text = '-enable-pretty-printing',
          description =  'enable pretty printing',
          ignoreFailures = false
      },
      {
          text = function()
            return 'set args ' .. vim.fn.input("args: ")
            -- return vim.fn.input("args: ", 'set args ')
          end,
          description = 'args',
          ignoreFailures = flase
      },
    },
  },
  {
    name = 'Attach to gdbserver :1234',
    type = 'cppdbg',
    request = 'launch',
    MIMode = 'gdb',
    miDebuggerServerAddress = 'localhost:1234',
    miDebuggerPath = vim.fn.stdpath("data") .. '/dapinstall/ccppr_vsc/gdb-10.2/gdb/gdb',
    cwd = '${workspaceFolder}',
    program = function()
      return vim.fn.input('Path to executable: ', vim.fn.getcwd() .. '/', 'file')
    end,
    setupCommands = {
      {
          text = '-enable-pretty-printing',
          description =  'enable pretty printing',
          ignoreFailures = false
      },
    },
  },
}

------------------------------------------------------------------------------
-- dap codelldb
------------------------------------------------------------------------------
local dap = require('dap')

-- dap.adapters.codelldb = {
--     type = 'server',
--     host = '127.0.0.1',
--     port = 1234
-- }
-- dap.configurations.cpp = {
--     {
--         name = "z3",
--         type = 'codelldb',
--         request = 'launch',
--         program = os.getenv("HOME") .. '/smt/z3/build/z3',
--         cwd = '${workspaceFolder}',
--         args = { '/home/linjk/smt/2021_QF_BV/20210219-Sydr/master/yices/predicate_2066.smt2', '-tr:"th_rewriter_step"' },
--         terminal = 'integrated',
--     },
--     {
--         name = "Launch",
--         type = 'codelldb',
--         request = 'launch',
--         program = function()
--           return vim.fn.input('Path to executable: ', vim.fn.getcwd() .. '/', 'file')
--         end,
--         cwd = '${workspaceFolder}',
--         terminal = 'integrated'
--     }
-- }
dap.configurations.c = dap.configurations.cpp
dap.configurations.rust = dap.configurations.cpp
dap.defaults.fallback.exception_breakpoints = {'raised', 'uncaught'}

------------------------------------------------------------------------------
-- dap ui
------------------------------------------------------------------------------
-- dap.defaults.fallback.terminal_win_cmd = '7split new'
require("dapui").setup({
  icons = { expanded = "▾", collapsed = "▸" },
  mappings = {
    -- Use a table to apply multiple mappings
    expand = { "<CR>", "<2-LeftMouse>" },
    open = "o",
    remove = "d",
    edit = "e",
    repl = "r",
    toggle = "t",
  },
  -- Expand lines larger than the window
  -- Requires >= 0.7
  expand_lines = vim.fn.has("nvim-0.7"),
  -- Layouts define sections of the screen to place windows.
  -- The position can be "left", "right", "top" or "bottom".
  -- The size specifies the height/width depending on position.
  -- Elements are the elements shown in the layout (in order).
  -- Layouts are opened in order so that earlier layouts take priority in window sizing.
  layouts = {
    {
      elements = {
      -- Elements can be strings or table with id and size keys.
        { id = "scopes", size = 0.25 },
        "breakpoints",
        "stacks",
        "watches",
      },
      size = 40,
      position = "left",
    },
    {
      elements = {
        "repl",
        "console",
      },
      size = 10,
      position = "bottom",
    },
  },
  floating = {
    max_height = nil, -- These can be integers or a float between 0 and 1.
    max_width = nil, -- Floats will be treated as percentage of your screen.
    border = "single", -- Border style. Can be "single", "double" or "rounded"
    mappings = {
      close = { "q", "<Esc>" },
    },
  },
  windows = { indent = 1 },
  render = {
    max_type_length = nil, -- Can be integer or nil.
  }
})

local dap = require('dap')
local dapui = require("dapui")
dap.listeners.after.event_initialized["dapui_config"] = function()
  dapui.open()
  vim.api.nvim_command('wincmd j')
end
dap.listeners.before.event_terminated["dapui_config"] = function()
  dapui.close()
end
dap.listeners.before.event_exited["dapui_config"] = function()
  dapui.close()
end

------------------------------------------------------------------------------
-- symbols-outline
------------------------------------------------------------------------------
-- local opts = {
--   highlight_hovered_item = true,
--   auto_preview = true,
--   position = 'right',
--   relative_width = true,
--   width = 40,
--   show_numbers = false,
--   preview_bg_highlight = 'Pmenu',
-- }
require("symbols-outline").setup()


------------------------------------------------------------------------------
-- goto-preview
------------------------------------------------------------------------------
-- require('goto-preview').setup {
--   height = 20;
--   vim.api.nvim_set_keymap("n", "gp", "<cmd>lua require('goto-preview').goto_preview_definition()<CR>", {noremap=true});
--   }


------------------------------------------------------------------------------
-- hop.nvim
------------------------------------------------------------------------------
-- require('hop').setup {
--   vim.api.nvim_set_keymap('n', 't', "<cmd>HopWord<cr>", {});
--   }

------------------------------------------------------------------------------
-- leap.nvim
------------------------------------------------------------------------------
-- require('leap').setup {
-- }
require('leap').set_default_keymaps()
------------------------------------------------------------------------------

-- which-key
------------------------------------------------------------------------------
require("which-key").setup {
    -- your configuration comes here
    -- or leave it empty to use the default settings
    -- refer to the configuration section below
  }

-- require('auto-session').setup()

------------------------------------------------------------------------------
-- neogit
------------------------------------------------------------------------------
require('neogit').setup {}

------------------------------------------------------------------------------
-- telescope
------------------------------------------------------------------------------
local actions = require("telescope.actions")
require('telescope').setup {
  defaults = {
   layout_strategy = "vertical",
    layout_config = {
      -- height = vim.o.lines, -- maximally available lines
      -- width = vim.o.columns, -- maximally available columns
      -- mirror = true,
      preview_cutoff = 30,
      preview_height = 0.5, -- 50% of available lines
    },
    mappings = {
      n = {
        ["q"] = actions.close
      },
      i = {
        ["<esc>"] = actions.close
      },
    }
  },
  pickers = {
    find_files = {
      mappings = {
        n = {
          ["cd"] = function(prompt_bufnr)
          local selection = require("telescope.actions.state").get_selected_entry()
          local dir = vim.fn.fnamemodify(selection.path, ":p:h")
          require("telescope.actions").close(prompt_bufnr)
          -- Depending on what you want put `cd`, `lcd`, `tcd`
          vim.cmd(string.format("silent lcd %s", dir))
        end
        }
      }
    },
  },
}
require('telescope').load_extension('fzf')

local builtin = require("telescope.builtin")
vim.keymap.set({'n'}, '<leader><leader>', builtin.commands)
vim.keymap.set({'n'}, '<leader>j', builtin.jumplist)
vim.keymap.set({'n'}, '<leader>rg', builtin.live_grep)
vim.keymap.set({'n'}, '<leader>`', builtin.marks)
vim.keymap.set({'n'}, '<leader>rw', function() builtin.grep_string({search_dirs = {vim.fn.expand("%:p")}}) end)
vim.keymap.set({'n'}, '<leader>rW', builtin.grep_string)

-- Falling back to find_files if git_files can't find a .git directory
project_files = function()
  local in_git_repo = vim.fn.systemlist"git rev-parse --is-inside-work-tree"[1] == 'true'
  if in_git_repo then
    require("telescope.builtin").git_files()
  else
    require("telescope.builtin").find_files()
  end
end

vim.keymap.set({'n'}, '<leader>f', project_files, {noremap = true, silent = true})
vim.keymap.set({'n'}, '<leader>F', builtin.find_files)
-- vim.keymap.set({'n'}, '<leader>f', builtin.git_files)


------------------------------------------------------------------------------
-- toggleterm
------------------------------------------------------------------------------
require("toggleterm").setup{
  direction = 'float',
  open_mapping = [[<c-\>]],
  -- vim.api.nvim_set_keymap('n', '<c-t>', "<cmd>ToggleTerm<cr>", {});
}

------------------------------------------------------------------------------
-- nvim-ufo
------------------------------------------------------------------------------
vim.wo.foldcolumn = '1'
vim.wo.foldlevel = 99 -- feel free to decrease the value
vim.wo.foldenable = true
local capabilities = vim.lsp.protocol.make_client_capabilities()
capabilities.textDocument.foldingRange = {
    dynamicRegistration = false,
    lineFoldingOnly = true
}

local handler = function(virtText, lnum, endLnum, width, truncate)
    local newVirtText = {}
    local suffix = ('  %d '):format(endLnum - lnum)
    local sufWidth = vim.fn.strdisplaywidth(suffix)
    local targetWidth = width - sufWidth
    local curWidth = 0
    for _, chunk in ipairs(virtText) do
        local chunkText = chunk[1]
        local chunkWidth = vim.fn.strdisplaywidth(chunkText)
        if targetWidth > curWidth + chunkWidth then
            table.insert(newVirtText, chunk)
        else
            chunkText = truncate(chunkText, targetWidth - curWidth)
            local hlGroup = chunk[2]
            table.insert(newVirtText, {chunkText, hlGroup})
            chunkWidth = vim.fn.strdisplaywidth(chunkText)
            -- str width returned from truncate() may less than 2nd argument, need padding
            if curWidth + chunkWidth < targetWidth then
                suffix = suffix .. (' '):rep(targetWidth - curWidth - chunkWidth)
            end
            break
        end
        curWidth = curWidth + chunkWidth
    end
    table.insert(newVirtText, {suffix, 'MoreMsg'})
    return newVirtText
end
--
-- global handler
require('ufo').setup({
    fold_virt_text_handler = handler
})
--
-- -- buffer scope handler
-- -- will override global handler if it is existed
-- local bufnr = vim.api.nvim_get_current_buf()
-- require('ufo').setVirtTextHandler(bufnr, handler)

local Hydra = require("hydra")

Hydra({
	name = "Resize Window",
	mode = { "n" },
	body = "<C-w>",
	config = {
		-- color = "pink",
	},
	heads = {
		-- resizing window
		{ "h", "<C-w>3<" },
		{ "l", "<C-w>3>" },
		{ "k", "<C-w>2+" },
		{ "j", "<C-w>2-" },

		-- equalize window sizes
		{ "=", "<C-w>=" },

		-- exit this Hydra
		{ "q", nil, { exit = true, nowait = true } },
		{ "<Esc>", nil, { exit = true, nowait = true } },
	},
})

------------------------------------------------------------------------------
-- b0o/incline.nvim
------------------------------------------------------------------------------
require('incline').setup {
  window = {
    placement = {
      horizontal = "right",
      vertical = "top",
    },
  margin = {
    horizontal = 0,
    vertical = 2,
    },
  }
}

------------------------------------------------------------------------------
-- lspsaga
------------------------------------------------------------------------------
-- local saga = require 'lspsaga'
--
-- saga.init_lsp_saga({
--   code_action_lightbulb = {
--     enable = false,
--   },
-- })
--
-- vim.keymap.set("n", "gh", require("lspsaga.finder").lsp_finder, { silent = true,noremap = true })
-- local action = require("lspsaga.codeaction")
-- vim.keymap.set("n", "gf", action.code_action, { silent = true,noremap = true })
-- vim.keymap.set("v", "gf", function()
--     vim.fn.feedkeys(vim.api.nvim_replace_termcodes("<C-U>", true, false, true))
--     action.range_code_action()
-- end, { silent = true,noremap =true })
-- vim.keymap.set("n", "<leader>cd", require("lspsaga.diagnostic").show_line_diagnostics, { silent = true,noremap = true })
-- vim.keymap.set("n", "[e", require("lspsaga.diagnostic").goto_prev, { silent = true, noremap =true })
-- vim.keymap.set("n", "]e", require("lspsaga.diagnostic").goto_next, { silent = true, noremap =true })
-- -- show hover doc and press twice will jumpto hover window
-- vim.keymap.set("n", "K", require("lspsaga.hover").render_hover_doc, { silent = true })
-- -- or use command
-- vim.keymap.set("n", "K", "<cmd>Lspsaga hover_doc<CR>", { silent = true })
-- vim.keymap.set("n", "<leader>rn", require("lspsaga.rename").lsp_rename, { silent = true,noremap = true })
--
-- local action = require("lspsaga.action")
-- -- scroll down hover doc or scroll in definition preview
-- vim.keymap.set("n", "<a-f>", function()
--     action.smart_scroll_with_saga(1)
-- end, { silent = true })
-- -- scroll up hover doc
-- vim.keymap.set("n", "<a-b>", function()
--     action.smart_scroll_with_saga(-1)
-- end, { silent = true })

------------------------------------------------------------------------------
-- distant
------------------------------------------------------------------------------
require('distant').setup {
  -- Applies Chip's personal settings to every machine you connect to
  --
  -- 1. Ensures that distant servers terminate with no connections
  -- 2. Provides navigation bindings for remote directories
  -- 3. Provides keybinding to jump into a remote file's parent directory
  ['*'] = require('distant.settings').chip_default()
  }

------------------------------------------------------------------------------
-- bqf
------------------------------------------------------------------------------
vim.cmd([[
    hi BqfPreviewBorder guifg=#50a14f ctermfg=71
    hi link BqfPreviewRange Search
]])

require('bqf').setup({
    auto_enable = true,
    auto_resize_height = true, -- highly recommended enable
    preview = {
        win_height = 12,
        win_vheight = 12,
        delay_syntax = 80,
        border_chars = {'┃', '┃', '━', '━', '┏', '┓', '┗', '┛', '█'},
        should_preview_cb = function(bufnr, qwinid)
            local ret = true
            local bufname = vim.api.nvim_buf_get_name(bufnr)
            local fsize = vim.fn.getfsize(bufname)
            if fsize > 100 * 1024 then
                -- skip file size greater than 100k
                ret = false
            elseif bufname:match('^fugitive://') then
                -- skip fugitive buffer
                ret = false
            end
            return ret
        end
    },
    -- make `drop` and `tab drop` to become preferred
    func_map = {
        drop = 'o',
        openc = 'O',
        split = '<C-s>',
        tabdrop = '<C-t>',
        tabc = '',
        ptogglemode = 'z,',
    },
    filter = {
        fzf = {
            action_for = {['ctrl-s'] = 'split', ['ctrl-t'] = 'tab drop'},
            extra_opts = {'--bind', 'ctrl-o:toggle-all', '--prompt', '> '}
        }
    }
})

------------------------------------------------------------------------------
-- windows.nvim
------------------------------------------------------------------------------
vim.o.winwidth = 20
vim.o.winminwidth = 20
vim.o.equalalways = false
vim.keymap.set('n', '<C-w>z', '<Cmd>WindowsMaximize<CR>')
vim.keymap.set('n', '<leader>z', '<Cmd>WindowsMaximize<CR>')
vim.keymap.set('n', '<C-w>a', '<Cmd>WindowsToggleAutowidth<CR>')
require('windows').setup {
  autowidth = {			--		       |windows.autowidth|
    enable = false
  }
}

END

set encoding=UTF-8
set foldmethod=expr
set foldexpr=nvim_treesitter#foldexpr()
set nofoldenable
set number
" set lazyredraw
" syntax enable
set termguicolors
set confirm
set autoindent
set cindent
set smartindent
set tabstop=2
set softtabstop=-1
set shiftwidth=2
set expandtab
set smarttab
set nojoinspaces
set noswapfile
set ignorecase
set hlsearch
set smartcase
set incsearch
set backspace=indent,eol,start
set showcmd
set wildmenu
set ttimeout
set ttimeoutlen=100
" set timeoutlen=500
" set completeopt=longest,menu
set completeopt=menu,menuone,noselect
set scrolloff=5
set autoread
set cursorline
set hidden
set clipboard=unnamedplus
set shortmess+=c
set splitbelow
set splitright
set updatetime=100
set mouse=a
set laststatus=3 "show status line even when only single window is opened
" set statusline+=%{zoom#statusline()}
colorscheme dayfox
set background=light
hi MatchParen ctermbg=lightblue guibg=lightgreen cterm=italic gui=italic
" hi clear CurSearch

autocmd FocusGained,BufEnter,CursorHold,CursorHoldI * if mode() != 'c' | checktime | endif
    " notification after file change
      autocmd FileChangedShellPost *
        \ echohl WarningMsg | echo "File changed on disk. Buffer reloaded." | echohl None

" let g:python3_host_prog = '/usr/local/bin/python3'

inoremap <silent> jk <esc>
" cnoremap <silent> jk <c-c>
if (has('nvim'))
  tnoremap <silent> jk <c-\><c-n>
endif
xnoremap <silent> v <c-c>

nnoremap <c-g> 1<c-g>

" vsnip
" imap <expr> <CR>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<CR>'
" smap <expr> <CR>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<CR>'
" imap <expr> <C-j>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<C-j>'
" smap <expr> <C-j>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<C-j>'
" imap <expr> <C-k> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<C-k>'
" smap <expr> <C-k> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<C-k>'
" let g:UltiSnipsExpandTrigger="<CR>"
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger="<c-k>"
let g:UltiSnipsSnippetDirectories=["UltiSnips", $HOME."/.vim/mysnippets"]

" nvim-cmp
nnoremap <silent> K <Cmd>lua vim.lsp.buf.hover()<CR>
nnoremap <silent> gd :lua vim.lsp.buf.definition()<CR>
nnoremap <silent> gi :lua vim.lsp.buf.implementation()<CR>
nnoremap <silent> g\ <cmd>vsplit<bar>lua vim.lsp.buf.definition()<CR>
nnoremap <silent> g- <cmd>split<bar>lua vim.lsp.buf.definition()<CR>
nnoremap <silent> gr :lua vim.lsp.buf.references()<CR>
nnoremap <silent> gf <cmd>lua vim.lsp.buf.code_action()<CR>
nnoremap <silent> [e <cmd>lua vim.diagnostic.goto_prev()<CR>
nnoremap <silent> ]e <cmd>lua vim.diagnostic.goto_next()<CR>
nnoremap <silent> <space>rn :lua vim.lsp.buf.rename()<CR>
command! -nargs=0 Format :lua vim.lsp.buf.formatting()<CR>

" symbols-outline
nnoremap <silent> gt <cmd>SymbolsOutline<CR>


" dap
nnoremap <silent> <F5> :lua require'dap'.continue()<CR>
nnoremap <silent> <leader>n :lua require'dap'.step_over()<CR>
nnoremap <silent> <leader>s :lua require'dap'.step_into()<CR>
" nnoremap <silent> <leader> :lua require'dap'.step_out()<CR>
nnoremap <silent> <leader>k <Cmd>lua require("dapui").eval()<CR>
" nnoremap <silent> <leader>k <Cmd>lua require("dap.ui.widgets").hover()<CR>
nnoremap <silent> <leader>b :lua require'dap'.toggle_breakpoint()<CR>
nnoremap <silent> <leader>B :lua require'dap'.set_breakpoint(vim.fn.input('Breakpoint condition: '))<CR>

nnoremap <silent> <leader>lp :lua require'dap'.set_breakpoint(nil, nil, vim.fn.input('Log point message: '))<CR>
nnoremap <silent> <leader>dl :lua require'dap'.run_last()<CR>
nnoremap <silent> <leader>du :lua require'dapui'.toggle()<CR>
" nnoremap <silent> <leader>dr :lua require'dap'.repl.close()<CR> :lua require'dap'.repl.open({height = 7}, 'wincmd j \| leftabove vsplit' )<CR>
" nnoremap <silent> <leader>dr :lua require'dap'.repl.toggle({height = 7}, 'wincmd j \| leftabove vsplit' )<CR>
" nnoremap <silent> <leader>df :lua require("dapui").float_element('watches')<CR>

augroup dap-repl
  autocmd!
  autocmd FileType dap-repl lua require('dap.ext.autocompl').attach()
  autocmd FileType dap-repl nnoremap<buffer> n <cmd>lua require('dap').step_over()<CR>
  autocmd FileType dap-repl nnoremap<buffer> s <cmd>lua require('dap').step_into()<CR>
  autocmd FileType dap-repl nnoremap<buffer> S <cmd>lua require('dap').step_out()<CR>
  autocmd FileType dap-repl nnoremap<buffer> o <cmd>lua require('dap').step_out()<CR>
  autocmd FileType dap-repl nnoremap<buffer> c <cmd>lua require('dap').continue()<CR>
  autocmd FileType dap-repl inoremap<buffer> <c-k> <c-w>k
augroup end

" augroup treesitter-context
"   autocmd!
"   autocmd CursorMoved * silent TSContextDisable
" augroup end
" nnoremap <silent> <leader>ct <cmd>TSContextToggle<CR>

nnoremap <silent> <leader>. :cd %:p:h<CR>
nnoremap <leader>\ :vsplit<CR>
nnoremap <leader>- :split<CR>

" Jump to the last edited line
autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"zz" | endif

augroup latex
  autocmd!
  autocmd filetype plaintex,tex setlocal colorcolumn=80
        \ tabstop=2
        \ shiftwidth=2
        \ softtabstop=2
augroup end

" augroup c++
"   autocmd!
"   autocmd filetype c,cpp setlocal foldmethod=syntax
" augroup end

nnoremap <silent> <expr> j (v:count == 0 ? 'gj' : 'j')
nnoremap <silent> <expr> k (v:count == 0 ? 'gk' : 'k')
noremap <silent> <leader>hc :noh<CR>
nnoremap <silent> = :vertical resize +5<cr>
nnoremap <silent> - :vertical resize -5<cr>
" nnoremap <silent> <leader>= :resize +5<cr>
" nnoremap <silent> <leader>- :resize -5<cr>

nnoremap <leader>w :update<cr>
nnoremap <Leader>q :q<cr>
nnoremap <Leader>Q :qa!<cr>

" Make Y behave like other capitals
nnoremap Y y$

" qq to record, Q to replay
nnoremap Q @q

" mark
nnoremap mp mP
nnoremap mo mO
nnoremap mi mI
nnoremap mu mU
nnoremap my mY
nnoremap `p `P
nnoremap `o `O
nnoremap `i `I
nnoremap `u `U
nnoremap `y `Y

" Open new line below and above current line
nnoremap <leader>o o<esc>
nnoremap <leader>O O<esc>

" ----------------------------------------------------------------------------
" Quickfix
" ----------------------------------------------------------------------------
nnoremap <silent> <leader>c :cclose<bar>lclose<cr>
nnoremap <silent> ]q :cnext<cr>zz
nnoremap <silent> [q :cprev<cr>zz
nnoremap <silent> ]l :lnext<cr>zz
nnoremap <silent> [l :lprev<cr>zz

" ----------------------------------------------------------------------------
" Buffers
" ----------------------------------------------------------------------------
nnoremap ]b :bnext<cr>
nnoremap [b :bprev<cr>

" ----------------------------------------------------------------------------
" Tabs
" ----------------------------------------------------------------------------
nnoremap ]t :tabn<cr>
nnoremap [t :tabp<cr>

" ----------------------------------------------------------------------------
" <tab> / <s-tab> | Circular windows navigation
" ----------------------------------------------------------------------------
nnoremap <tab>   <c-w>w
nnoremap <S-tab> <c-w>W

" Jump list (to newer position)
nnoremap <C-p> <C-i>

" ----------------------------------------------------------------------------
" Readline-style key bindings in command-line (excerpt from rsi.vim)
" ----------------------------------------------------------------------------
cnoremap        <C-A> <Home>
cnoremap        <C-B> <Left>
cnoremap <expr> <C-D> getcmdpos()>strlen(getcmdline())?"\<Lt>C-D>":"\<Lt>Del>"
cnoremap <expr> <C-F> getcmdpos()>strlen(getcmdline())?&cedit:"\<Lt>Right>"
cnoremap        <M-b> <S-Left>
cnoremap        <M-f> <S-Right>
silent! exe "set <S-Left>=\<Esc>b"
silent! exe "set <S-Right>=\<Esc>f"

" ----------------------------------------------------------------------------
" Help in new tabs
" ----------------------------------------------------------------------------
function! s:helptab()
  if &buftype == 'help'
    wincmd T
    nnoremap <buffer> q :q<cr>
  endif
endfunction
autocmd BufEnter *.txt call s:helptab()

" ----------------------------------------------------------------------------
" cop to toggle setting
" ----------------------------------------------------------------------------
function! s:map_change_option(...)
  let [key, opt] = a:000[0:1]
  let op = get(a:, 3, 'set '.opt.'!')
  execute printf("nnoremap co%s :%s<bar>set %s?<cr>", key, op, opt)
endfunction

call s:map_change_option('r', 'relativenumber')

" ----------------------------------------------------------------------------
" Zoom
" ----------------------------------------------------------------------------
" function! s:zoom()
"   if winnr('$') > 1
"     tab split
"   elseif len(filter(map(range(tabpagenr('$')), 'tabpagebuflist(v:val + 1)'),
"         \ 'index(v:val, '.bufnr('').') >= 0')) > 1
"     tabclose
"   endif
" endfunction
" nnoremap <silent> <leader>z :call <sid>zoom()<cr>

" ----------------------------------------------------------------------------
" :Root | Change directory to the root of the Git repository
" ----------------------------------------------------------------------------
function! s:root()
  let root = systemlist('git rev-parse --show-toplevel')[0]
  if v:shell_error
    echo 'Not in git repo'
  else
    execute 'lcd' root
    echo 'Changed directory to: '.root
  endif
endfunction
command! Root call s:root()


" fzf
" nnoremap <leader>f :Files<CR>
" nnoremap <leader>g :GFiles<CR>
" nnoremap <leader>F :Files 
" nnoremap <leader>rg :Rg<CR>
" " nnoremap <leader><leader> :Commands<CR>
"
" command! -bar MoveBack if &buftype == 'nofile' && (winwidth(0) < &columns / 3 || winheight(0) < &lines / 3) | execute "normal! \<c-w>\<c-p>" | endif
" " nnoremap <silent> <Leader><Leader> :MoveBack<BAR>Buffers<CR>
" nnoremap <silent> <Leader><Enter>  :MoveBack<BAR>Files<CR>
" nnoremap <silent> <Leader>`        :Marks<CR>

let g:fzf_action = {
      \ 'ctrl-t': 'tab split',
      \ 'ctrl-i': 'split',
      \ 'ctrl-s': 'vsplit' }
let g:fzf_colors =
      \ { 'fg':      ['fg', 'Normal'],
      \ 'bg':      ['bg', 'Normal'],
      \ 'hl':      ['fg', 'Comment'],
      \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
      \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
      \ 'hl+':     ['fg', 'Statement'],
      \ 'info':    ['fg', 'PreProc'],
      \ 'border':  ['fg', 'Ignore'],
      \ 'prompt':  ['fg', 'Conditional'],
      \ 'pointer': ['fg', 'Exception'],
      \ 'marker':  ['fg', 'Keyword'],
      \ 'spinner': ['fg', 'Label'],
      \ 'header':  ['fg', 'Comment'] }

" coc-translator
" popup
" nmap <Leader>tw <Plug>(coc-translator-p)
" echo
" nmap <Leader>e <Plug>(coc-translator-e)

" tagbar
" noremap <silent> gt :TagbarToggle<CR>
" let g:tagbar_sort = 0

" ----------------------------------------------------------------------------
" :A
" ----------------------------------------------------------------------------
function! s:a(cmd)
  let name = expand('%:r')
  let ext = tolower(expand('%:e'))
  let sources = ['c', 'cc', 'cpp', 'cxx', 'C']
  let headers = ['h', 'hh', 'hpp', 'hxx', 'H']
  for pair in [[sources, headers], [headers, sources]]
    let [set1, set2] = pair
    if index(set1, ext) >= 0
      for h in set2
        let aname = name.'.'.h
        for a in [aname, toupper(aname)]
          if filereadable(a)
            execute a:cmd a
            return
          end
        endfor
      endfor
    endif
  endfor
endfunction
command! A call s:a('e')
command! AV call s:a('botright vertical split')
nnoremap <silent> <leader>a :call <sid>a('e')<cr>

" tex-conceal
" set conceallevel=2
" let g:tex_conceal="abdgm"

" vimtex
" let g:tex_flavor = 'latex'
" " let g:vimtex_view_general_viewer = 'mupdf'
" let g:vimtex_view_general_viewer = 'okular'
" let g:vimtex_view_general_options = '--unique file:@pdf\#src:@line@tex'
" let g:vimtex_view_general_options_latexmk = '--unique'
" let g:vimtex_quickfix_latexlog = {'default' : 0}
" " let g:vimtex_quickfix_latexlog = {
" "       \ 'overfull' : 0,
" "       \ 'underfull' : 0,
" "       \ 'font' : 0,
" "       \}
" let g:vimtex_compiler_progname='nvr'

" gruvbox
" let g:gruvbox_italic=1
" colorscheme gruvbox
" set background=dark

" drewtempelmeyer/palenight.vim
" colorscheme palenight

" nvim-gdb
" command! -complete=file -nargs=1 Gdb call plug#load('nvim-gdb') | GdbStart gdb -q <args>
" let g:nvimgdb_disable_start_keymaps = 1
" nmap <leader>v :GdbEvalWord<CR>
" vmap <leader>v :GdbEvalRange<CR>

" auto-pairs
" augroup auto-pairs
"   autocmd!
"   autocmd FileType plaintex,tex let g:AutoPairs['$']='$'
" augroup END

" visual star
function! s:VSetSearch()
  let temp = @@
  norm! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  " Use this line instead of the above to match matches spanning across lines
  "let @/ = '\V' . substitute(escape(@@, '\'), '\_s\+', '\\_s\\+', 'g')
  call histadd('/', substitute(@/, '[?/]', '\="\\%d".char2nr(submatch(0))', 'g'))
  let @@ = temp
endfunction
vnoremap * :<C-u>call <SID>VSetSearch()<CR>/<CR>
vnoremap # :<C-u>call <SID>VSetSearch()<CR>?<CR>

" vim-textobj-user
let g:textobj_numeral_pattern = '\%(\<[[:digit:]]\+\%(\.[[:digit:]]\+\)\=\%([Ee][[:digit:]]\+\)\=\>\|\<0[xXbBoOdD][[:xdigit:]]\+\>\)'
let g:textobj_solution_pattern = g:textobj_numeral_pattern . '(' . g:textobj_numeral_pattern . ')'
call textobj#user#plugin('number', {
      \   '-': {
        \     'pattern': g:textobj_numeral_pattern,
        \     'select': ['an', 'in'],
        \   },
        \   's': {
          \     'pattern': g:textobj_solution_pattern,
          \     'select': ['as', 'is'],
          \   }
          \ })

" ----------------------------------------------------------------------------
" goyo.vim + limelight.vim
" ----------------------------------------------------------------------------
let g:limelight_paragraph_span = 1
let g:limelight_priority = -1

function! s:goyo_enter()
  if has('gui_running')
    set fullscreen
    set background=light
    set linespace=7
  elseif exists('$TMUX')
    silent !tmux set status off
  endif
  Limelight
  let &l:statusline = '%M'
  hi StatusLine ctermfg=red guifg=red cterm=NONE gui=NONE
endfunction

function! s:goyo_leave()
  if has('gui_running')
    set nofullscreen
    set background=dark
    set linespace=0
  elseif exists('$TMUX')
    silent !tmux set status on
  endif
  Limelight!
endfunction

autocmd! User GoyoEnter nested call <SID>goyo_enter()
autocmd! User GoyoLeave nested call <SID>goyo_leave()

nnoremap <Leader>G :Goyo<CR>
nnoremap <Leader>mm :make<CR>

" indentLine
" let g:indentLine_char = '┆'
" let g:indentLine_color_gui = '#d65d0e'
" let g:indentLine_setColors = 0

" vim-airline
" let g:airline_powerline_fonts = 1
" let g:airline#extensions#tabline#enabled = 1
" let g:airline#extensions#tabline#tab_nr_type= 2

" ----------------------------------------------------------------------------
" coc-vim
" ----------------------------------------------------------------------------
" Use tab for trigger completion with characters ahead and navigate.
" Use command ':verbose imap <tab>' to make sure tab is not mapped by other plugin.
" inoremap <silent><expr> <TAB>
"       \ pumvisible() ? "\<C-n>" :
"       \ <SID>check_back_space() ? "\<TAB>" :
"       \ coc#refresh()
" inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"
"
" function! s:check_back_space() abort
"   let col = col('.') - 1
"   return !col || getline('.')[col - 1]  =~# '\s'
" endfunction
"
" " Use <c-space> for trigger completion.
" inoremap <silent><expr> <c-space> coc#refresh()
"
" " Use <cr> for confirm completion, `<C-g>u` means break undo chain at current position.
" " Coc only does snippet and additional edit on confirm.
" inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"
"
" " snippet
" let g:coc_snippet_next = '<c-j>'
" let g:coc_snippet_prev = '<c-k>'
"
" " Use `[c` and `]c` for navigate diagnostics
" nmap <silent> [d <Plug>(coc-diagnostic-prev)
" nmap <silent> ]d <Plug>(coc-diagnostic-next)
"
" " Remap keys for gotos
" nmap <silent> gd <Plug>(coc-definition)
" nmap <silent> gy <Plug>(coc-type-definition)
" nmap <silent> gi <Plug>(coc-implementation)
" nmap <silent> gr <Plug>(coc-references)
" nmap <silent> gf <Plug>(coc-fix-current)
"
" " Use K for show documentation in preview window
" nnoremap <silent> K :call <SID>show_documentation()<CR>
"
" function! s:show_documentation()
"   if &filetype == 'vim'
"     execute 'h '.expand('<cword>')
"   else
"     call CocAction('doHover')
"   endif
" endfunction
"
" augroup coc
"   autocmd!
"   " Update signature help on jump placeholder
"   autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
" augroup end
"
"
" " Highlight symbol under cursor on CursorHold
" autocmd CursorHold * silent call CocActionAsync('highlight')
"
" " Remap for rename current word
" nmap <leader>rn <Plug>(coc-rename)
"
" " Use `:Fold` to fold current buffer
" command! -nargs=? Fold :call     CocAction('fold', <f-args>)
"
" " coc-explorer
" " nmap ge :CocCommand explorer<CR>
" " let g:indentLine_fileTypeExclude = ['coc-explorer']
"
"
" " Using CocList
" command! Coc CocList diagnostics
"
" nnoremap <leader>o :CocList --auto-preview outline<CR>
" nnoremap <silent> <leader>lv  :<C-u>CocCommand latex.ForwardSearch<CR>
" nnoremap <silent> <leader>lb  :<C-u>CocCommand latex.Build<CR>
" nnoremap <silent> <leader>lc  :<C-u>!latexmk -c<CR>
" nnoremap <silent> <leader>lC  :<C-u>!latexmk -C<CR>
"
" " augroup fmt
" "  autocmd!
" "  autocmd BufWritePre * try | undojoin | :call CocAction('format') | catch /^Vim\%((\a\+)\)\=:E790/ | finally | silent :call CocAction('format') | endtry
" " augroup END
"
" " Use `:Format` to format current buffer
" command! -nargs=0 Format :call CocAction('format')
"
" " coc_status for airline
" let g:airline_section_error = '%{airline#util#wrap(airline#extensions#coc#get_error(),0)}'
" let g:airline_section_warning = '%{airline#util#wrap(airline#extensions#coc#get_warning(),0)}'

" vimspector
" let &packpath ="~/.vim"
" let g:vimspector_enable_mappings = 'HUMAN'
" packadd! vimspector
